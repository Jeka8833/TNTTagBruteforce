#[macro_use]
extern crate lazy_static;
extern crate rayon;

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;
use std::sync::{Arc, Mutex};

use atomic_counter::{AtomicCounter, RelaxedCounter};
use rayon::prelude::*;

const START: f64 = 0.01;
const STOP: f64 = 0.1;
const PRECISION: f64 = 10u32.pow(7) as f64;


const START_INT: u32 = (START * PRECISION) as u32;
const STOP_INT: u32 = (STOP * PRECISION) as u32;

const VALUE: [i16; 554] = [-5768, -4265, -3926, -3756, -3392, -3206, -3017, -3016, -2832, -2824,
    -2666, -2627, -2555, -2426, -2379, -2264, -2221, -2170, -2085, -2067, -2011, -1987, -1978,
    -1866, -1847, -1821, -1820, -1813, -1798, -1783, -1737, -1688, -1661, -1606, -1603, -1599,
    -1595, -1592, -1580, -1578, -1574, -1555, -1550, -1529, -1523, -1501, -1458, -1451, -1392,
    -1384, -1381, -1377, -1369, -1360, -1357, -1356, -1351, -1332, -1327, -1311, -1271, -1260,
    -1257, -1238, -1232, -1223, -1162, -1158, -1155, -1151, -1146, -1130, -1129, -1094, -1089,
    -1088, -1084, -1083, -1081, -1046, -1043, -1022, -1020, -1018, -995, -950, -935, -915, -902,
    -899, -883, -882, -881, -877, -872, -868, -861, -856, -852, -824, -817, -809, -804, -797, -796,
    -765, -718, -699, -691, -683, -679, -675, -662, -661, -630, -628, -624, -602, -598, -592, -591,
    -586, -573, -570, -569, -564, -528, -459, -447, -438, -429, -424, -421, -399, -393, -388, -378,
    -355, -351, -346, -342, -339, -217, -213, -205, -201, -178, -175, -171, -163, -158, -152, -147,
    -143, -139, -138, -131, -128, -110, -105, -102, -90, -75, 44, 53, 57, 62, 67, 72, 75, 77, 80,
    92, 93, 98, 99, 104, 112, 116, 125, 138, 155, 232, 241, 278, 289, 291, 300, 304, 308, 309, 313,
    318, 323, 328, 331, 333, 339, 344, 346, 349, 354, 357, 358, 362, 367, 371, 376, 384, 412, 458,
    542, 548, 550, 552, 556, 561, 565, 569, 570, 574, 579, 584, 589, 592, 593, 594, 595, 600, 604,
    606, 609, 611, 613, 617, 634, 635, 798, 814, 818, 822, 827, 831, 832, 836, 841, 846, 849, 850,
    851, 856, 859, 860, 862, 864, 867, 868, 869, 878, 883, 888, 890, 891, 899, 909, 956, 984, 1066,
    1085, 1087, 1089, 1094, 1096, 1099, 1100, 1101, 1102, 1103, 1106, 1107, 1108, 1112, 1113, 1116,
    1118, 1121, 1123, 1125, 1128, 1129, 1130, 1132, 1134, 1139, 1144, 1149, 1151, 1152, 1153, 1160,
    1195, 1231, 1277, 1284, 1337, 1340, 1356, 1364, 1366, 1367, 1371, 1374, 1376, 1378, 1382, 1385,
    1387, 1390, 1391, 1392, 1395, 1396, 1401, 1406, 1410, 1411, 1412, 1416, 1419, 1422, 1427, 1429,
    1435, 1438, 1465, 1467, 1507, 1510, 1516, 1610, 1614, 1622, 1631, 1633, 1635, 1644, 1647, 1649,
    1651, 1654, 1658, 1659, 1663, 1667, 1668, 1673, 1678, 1683, 1684, 1688, 1689, 1690, 1692, 1693,
    1713, 1726, 1753, 1763, 1796, 1810, 1824, 1902, 1922, 1923, 1926, 1931, 1935, 1937, 1942, 1946,
    1947, 1950, 1951, 1955, 1957, 1961, 1962, 1967, 1970, 1973, 1982, 1989, 2002, 2087, 2108, 2146,
    2150, 2153, 2204, 2206, 2207, 2209, 2214, 2218, 2223, 2227, 2228, 2229, 2232, 2236, 2238, 2241,
    2246, 2251, 2252, 2253, 2257, 2262, 2273, 2277, 2298, 2311, 2334, 2379, 2456, 2465, 2493, 2495,
    2497, 2502, 2506, 2507, 2521, 2527, 2529, 2532, 2536, 2537, 2541, 2542, 2546, 2547, 2552, 2557,
    2562, 2576, 2579, 2620, 2621, 2628, 2656, 2663, 2669, 2685, 2686, 2703, 2706, 2707, 2721, 2724,
    2733, 2738, 2746, 2762, 2767, 2789, 2792, 2796, 2799, 2801, 2811, 2812, 2833, 2834, 2836, 2837,
    2838, 2841, 2843, 2845, 2848, 2853, 2854, 2858, 2859, 2870, 2886, 2919, 2947, 2963, 2974, 2976,
    3004, 3005, 3023, 3030, 3089, 3095, 3096, 3102, 3107, 3112, 3120, 3135, 3139, 3146, 3148, 3151,
    3156, 3161, 3166, 3167, 3172, 3173, 3177, 3183, 3200, 3253, 3257, 3263, 3308, 3371, 3390, 3391,
    3393, 3394, 3396, 3398, 3401, 3403, 3407, 3408, 3409, 3414, 3419, 3429, 3446, 3464, 3492, 3571,
    3590, 3639, 3649, 3680, 3706, 3708, 3711, 3714, 3716, 3721, 3722, 3727, 3740, 3760];

lazy_static! {
    static ref VALUE_F64: [f64; 554] = pre_calc_value_f64();
}

fn main() {
    let counter = RelaxedCounter::new(0);

    let results: Vec<_> = (START_INT..STOP_INT).into_par_iter().map(|i| {
        let shift = i as f64 / PRECISION;
        let count = count_good(shift);

        if counter.inc() % 1000 == 0 {
            println!("Progress: {}%", counter.get() as u32 * 100 / (STOP_INT - START_INT));
        }

        format!("{{{},{}}},", shift, count)
    }).collect();

    let path = Path::new("output.txt");

    let file = match File::create(path) {
        Err(why) => panic!("couldn't create: {}", why),
        Ok(file) => file,
    };

    let file = Arc::new(Mutex::new(BufWriter::new(file)));

    let mut file = file.lock().unwrap();
    for result in results {
        file.write_all(result.as_bytes()).unwrap();
    }

    file.flush().unwrap();
}

fn pre_calc_value_f64() -> [f64; 554] {
    let mut value_f64 = [0.0; 554];

    for i in 0..VALUE.len() {
        value_f64[i] = VALUE[i] as f64 / 8000.0;
    }

    return value_f64;
}

fn count_good(shift: f64) -> u32 {
    let mut count = 0;
    let mut last_value: i16 = i16::MIN;

    for val in [0.28725] {
        for ticks in 1..VALUE_F64.len() {
            let y = (calc_y(val, ticks, shift) * 8000.0) as i16;

            if last_value == y {
                break;
            }

            last_value = y;

            if VALUE.binary_search(&y).is_ok() {
                count += 1;
            }
        }
    }

/*    for array_index in 1..VALUE_F64.len() {
        let value = VALUE_F64[array_index];
        if value < 0.0 {
            continue;
        }

        let slice = &VALUE[..array_index];

        for ticks in 1..array_index {
            let y = (calc_y(value, ticks, shift) * 8000.0) as i16;

            if last_value == y {
                break;
            }

            last_value = y;

            if slice.binary_search(&y).is_ok() {
                count += 1;
            }
        }
    }
*/
    return count;
}

#[inline]
fn calc_y(init_velocity: f64, tick: usize, shift: f64) -> f64 {
    let mut velocity = init_velocity;

    for _i in 0..tick {
        velocity = (velocity - shift) * 0.9800000190734863;
    }

    return velocity;
}